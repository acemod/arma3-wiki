name: callExtension
description: |-
  Calls custom .dll also known as [[Extensions|Extension]]. The name of the extension is the name of the extension .dll without ".dll" part (or without "_x64.dll" part on 64-bit Arma). For example if the file is 'myExtension.dll' the name of the extension will be "myExtension". For 64-bit extensions, the name of the extension doesn't need to change and is still "myExtension". The game will automatically look for 'myExtension_x64.dll' when you use 64-bit Arma exe.
  <br><br>
  This command is blocking, meaning that the game will wait for the extension to return before continuing. This may cause FPS drop if extension is not optimised. If extension takes too long, consider making asynchronous extension, where the result of the work of the extension is collected in a separate call.
  <br><br>
  Currently there is no limit how much data you can send to the extension. However there is a limit on how much data you can return from extension in one call. The limit is known to the extension and is passed in {{hl| int outputSize}}. The limit may or may not change in the future and is currently 10240 bytes. It is up to extension designer to handle multipart results if returned data exceeds output limit.
  <br><br>
  Since Arma 3 v1.67 it is possible to pass array of arguments to extensions. The array of arguments could be anything and all elements will be converted to strings, however you might want to only send simple types like [[Boolean]]s, [[String]]s, [[Number]]s and [[Array]]s of all of the above. There is currently a limit on how many arguments can be sent and it is 2048 (since Arma 3 v1.92; previous limit: 1024). However an argument could be an [[Array]] itself, in this case extension maker will have to provide additional methods for parsing such arguments.
  <br><br>
  Possible error codes:
  * 101: SYNTAX_ERROR_WRONG_PARAMS_SIZE
  * 102: SYNTAX_ERROR_WRONG_PARAMS_TYPE
  * 201: PARAMS_ERROR_TOO_MANY_ARGS
  * 301: EXECUTION_WARNING_TAKES_TOO_LONG
  Each error will have entry in .rpt file with more details.<br><br>

  The extension execution timeout, after which {{hl|301: EXECUTION_WARNING_TAKES_TOO_LONG}} warning is issued, is hardcoded on clients and is 1000.0 milliseconds (1 second). On the server the default limit is also 1 second, however it is possible to set custom limit with {{hl|callExtReportLimit}} param (see [[server.cfg#Server_Options | Server Options]]).
  <br><br>
  If an extension with the given name can't be found (or it is found but doesn't implement the required interface properly / at all) the following error will be written into the RPT (In this example the given dll-name was "MyExtension"):
  <code style="display: block">14:27:07 CallExtension 'MyExtension' could not be found</code>
  <br>
  If an extension is not whitelisted with BattlEye (see [[Extensions]] for more info) it will be blocked on clients running with enabled BattlEye protection. RPT message outputted however is a little obscure:
  <code style="display: block">21:35:04 Call extension 'MyExtension' could not be loaded: Insufficient system resources exist to complete the requested service</code>
  <br>
  Since Arma 3 v1.69, {{hl|RVExtensionVersion}} interface (see source code example below) has been added, which is called by the engine on extension load and expects extension version. This interface is designed to work with both, Linux and Windows. The max buffer size is 32 bytes. The version information will then appear in .[[rpt]] file like so:
  <code style="display: block">19:06:36 CallExtension loaded: test_extension (.\test_extension.dll) [1.0.0.1]</code>
  <br>
  For more information see [[Extensions]].
  <br><br>
  <u>Linux specific</u><br>
  While on Windows the extension name is case-insensitive, on Linux the extension name is case-sensitive and should match the name of the .so file exactly (minus ".so" part).<br><br>

  {{Feature | important | If a user has '''anti-virus software real time protection running''', this could cause brand new extension to stutter the game and return with {{hl|EXECUTION_WARNING_TAKES_TOO_LONG}} when executed for the first time, because of the AV software scanning. After the extension is whitelisted by AV this should go away until a new version of the extension is installed. Perhaps a dummy call to the extension on init should be considered as a feature of implementation to account for that}}
  <br>

  '''<u>Extension Callback</u>'''

  Since Arma 3 v1.95 it is possible to call the game directly from the extension via function pointer provided when extension is called for the first time (assuming the extension implements at least one of the {{hl|RVExtension}} or {{hl|RVExtensionArgs}} methods). The function pointer passed over to {{hl|RVExtensionRegisterCallback}} method is of the following signature (see Example 4):
  <syntaxhighlight lang="cpp">int(*callbackProc)(char const *name, char const *function, char const *data)</syntaxhighlight>
  Calling this function pointer from extension will trigger [[Arma 3: Mission Event Handlers#ExtensionCallback | "ExtensionCallback"]] mission event handler with 3 user supplied params. The params are
  * {{hl|name}} - make it unique name, for example the extension name, so that other modders can quickly filter out calls from own extensions
  * {{hl|function}} - make it name of the function the extension sends the result to. (Note: The returned function is just a STRING! So [[compile]] is needed, before using [[call]] or [[spawn]], to execute it)
  * {{hl|data}} - make it the actual result. You can also format it as an array so it could be parsed by [[parseSimpleArray]]
  Calling function pointer returns an {{hl|int}}. This is the number of available slots in the input buffer left for this frame after your call and can range from 99 to -1. The buffer is processed and cleared every frame and the maximum number of slots that can be filled per frame is 100. If you are planning to call back with more than 100 results per frame, make sure your extension retries if it receives negative {{hl|int}}, which means the buffer was full and your call did not succeed. Ideally suited for callbacks from different threads, but if callback is initiated from the calling thread, the EH will fire on the next frame of game simulation. Needless to say, the "ExtensionCallback" event handler needs to exist before any callbacks, otherwise the data will just stay in the buffer. Removing all "ExtensionCallback" EHs clears the buffer as well as mission restart.

  '''<u>Extension Context</u>'''

  Since Arma 3 v2.11 the engine will call {{hl|RVExtensionContext}} method (if exists, see Example 5) and pass the following data:
  * {{hl|steamID}} of the client calling extension [[getPlayerUID]] or "0"
  * {{hl|fileSource}} from which the extension was executed or "" if done on the fly
  * {{hl|missionName}} [[missionNameSource]]
  * {{hl|serverName}} [[serverName]]
groups:
- System
syntax:
- call: !Binary
  - - extension
  - - function
  ret:
  - String
  - data sent back from extension; If the extensiion was not found an empty String will be returned
  params:
  - name: extension
    description: extension name
    typ: String
  - name: function
    description: data sent to the extension
    typ: String
- call: !Binary
  - - extension
  - - function
    - arguments
  ret:
  - ArrayUnknown
  - |-
    in format [result, returnCode, errorCode], where:
    * result: [[String]] - data sent back from extension. It is up to extension maker what it is.
    * returnCode: [[Number]] - integer return from extension method. It is up to extension maker to define it.
    * errorCode: [[Number]] - error code in case of command error (see description). 0 means no errors.
  params:
  - name: extension
    description: extension name
    typ: String
  - name: function
    description: extension function identifier
    typ: String
  - name: arguments
    description: 'function arguments. Could be array of [[Anything]], each element will be converted to [[String]] automatically. Current allowed max length of this array is 2048 (since Arma 3 v1.92; previous limit: 1024'
    typ: ArrayUnknown
  since:
    arma_3:
      major: 1
      minor: 68
argument_loc: Unspecified
effect_loc: Unspecified
since:
  arma_2_arrowhead:
    major: 1
    minor: 60
  take_on_helicopters:
    major: 1
    minor: 0
  arma_3:
    major: 0
    minor: 50
examples:
- _return = "myExtension" callExtension "stringToBeParsed";
- |
  _result = "test_extension" callExtension str weapons player;
  _result = "test_extension" callExtension ["fnc1", getUnitLoadout player];
  _result = "test_extension" callExtension ["fnc2", magazinesAmmoFull player];
  _result = "test_extension" callExtension ["fnc1", [weapons player, magazines player]];
- "_result = \"test_extension\" callExtension [\"fnc1\", [1, \"two\", true, [4, \"five\", false]]];\nparseSimpleArray (_result select 0) params [\"_number\",\"_string\",\"_boolean\",\"_array\"];\nsystemChat str [_number,_string,_boolean,_array];\n</sqf>\n<br>\n<u>Source Code</u> ({{Link|link= http://data.bistudio.com/a3data/test_extension.zip|text= Download .dll}})\n<spoiler>\nThis is an example of an extension compatible with both syntaxes. When using 1st syntax, the data is just copied from input to output. When using alt syntax, the arguments are parsed and then assembled back into string array in 2 ways: fnc1 and fnc2. fnc1 is a fraction faster.\n<syntaxhighlight lang=\"cpp\">\n#include <string>\n#include <vector>\n#include <iterator>\n#include <sstream>\n\n#define CURRENT_VERSION \"1.0.0.1\"\n\nextern \"C\"\n{\n\t//--- Engine called on extension load \n\t__declspec (dllexport) void __stdcall RVExtensionVersion(char *output, int outputSize);\n\t//--- STRING callExtension STRING\n\t__declspec (dllexport) void __stdcall RVExtension(char *output, int outputSize, const char *function);\n\t//--- STRING callExtension ARRAY\n\t__declspec (dllexport) int __stdcall RVExtensionArgs(char *output, int outputSize, const char *function, const char **args, int argsCnt);\n}\n\n//--- Extension version information shown in .rpt file\nvoid __stdcall RVExtensionVersion(char *output, int outputSize)\n{\n\t//--- max outputSize is 32 bytes\n\tstrncpy_s(output, outputSize, CURRENT_VERSION, _TRUNCATE);\n}\n\n//--- name callExtension function\nvoid __stdcall RVExtension(char *output, int outputSize, const char *function)\n{\n\tstd::string str = function;\n\tstrncpy_s(output, outputSize, (\"Input Was: \" + str).c_str(), _TRUNCATE);\n}\n\n//--- name callExtension [function, args]\nint __stdcall RVExtensionArgs(char *output, int outputSize, const char *function, const char **args, int argsCnt)\n{\n\tif (strcmp(function, \"fnc1\") == 0)\n\t{\n\t\t//--- Manually assemble output array\n\t\tint i = 0;\n\t\tstd::string str = \"[\";\n\n\t\t//--- Each argument can be accessed via args[n]\n\t\tif (argsCnt > 0)\n\t\t\tstr += args[i++];\n\n\t\twhile (i < argsCnt)\n\t\t{\n\t\t\tstr += \",\";\n\t\t\tstr += args[i++];\n\t\t}\n\n\t\tstr += \"]\";\n\n\t\t//--- Extension result\n\t\tstrncpy_s(output, outputSize, str.c_str(), _TRUNCATE);\n\n\t\t//--- Extension return code\n\t\treturn 100;\n\t}\n\n\telse if (strcmp(function, \"fnc2\") == 0)\n\t{\n\t\t//--- Parse args into vector\n\t\tstd::vector<std::string> vec(args, std::next(args, argsCnt));\n\n\t\tstd::ostringstream oss;\n\t\tif (!vec.empty())\n\t\t{\n\t\t\t//--- Assemble output array\n\t\t\tstd::copy(vec.begin(), vec.end() - 1, std::ostream_iterator<std::string>(oss, \",\"));\n\t\t\toss << vec.back();\n\t\t}\n\n\t\t//--- Extension result\n\t\tstrncpy_s(output, outputSize, (\"[\" + oss.str() + \"]\").c_str(), _TRUNCATE);\n\n\t\t//--- Extension return code\n\t\treturn 200;\n\t}\n\n\telse\n\t{\n\t\tstrncpy_s(output, outputSize, \"Avaliable Functions: fnc1, fnc2\", outputSize - 1);\n\t\treturn -1;\n\t}\n}\n</syntaxhighlight>\n</spoiler>"
- "fncToExecute_1 = { hint format [\"Extension Result 1: %1\", _this] };\nfncToExecute_2 = { hint format [\"Extension Result 2: %1\", _this] };\nfncToExecute_3 = { hint format [\"Extension Result 3: %1\", _this] };\n\naddMissionEventHandler [\"ExtensionCallback\", \n{\n\tparams [\"_name\", \"_function\", \"_data\"];\n\tif (_name isEqualTo \"test_callback\") then \n\t{ \n\t\tparseSimpleArray _data call (missionNamespace getVariable [_function, \n\t\t{ \n\t\t\thint \"Function does not exist!\"\n\t\t}]);\n\t};\n}];\n\n\"test_callback\" callExtension str \"test data\";\n</sqf>\n<br>\nHere is a minimal example of an extension utilising [[Arma 3: Mission Event Handlers#ExtensionCallback | extension callback]] (don't actually do it like this). ''fncToExecute_X'' function is called from \"ExtensionCallback\" event handler when it is triggered after 2 seconds of the extension call.\n<spoiler>\n<syntaxhighlight lang=\"cpp\">\n#include <thread>\n#include <string>\n#include <chrono>\n\nextern \"C\"\n{\n\t__declspec (dllexport) void __stdcall RVExtensionRegisterCallback(int(*callbackProc)(char const *name, char const *function, char const *data));\n\t__declspec (dllexport) void __stdcall RVExtension(char *output, int outputSize, const char *function);\n}\n\nint(*callbackPtr)(char const *name, char const *function, char const *data) = nullptr;\n\nvoid __stdcall RVExtensionRegisterCallback(int(*callbackProc)(char const *name, char const *function, char const *data))\n{\n\tcallbackPtr = callbackProc;\n}\n\nvoid __stdcall RVExtension(char *output, int outputSize, const char *function)\n{\n\tif (!callbackPtr)\n\t\treturn;\n\n\tstd::thread ([](std::string fnc)\n\t{\t\t\n\t\tusing namespace std::chrono_literals;\n\t\tfnc = \"[1,2,3,\" + fnc + \"]\";\n\n\t\tfor (int i = 1; i < 4; ++i) // run 3 times\n\t\t{\n\t\t\tstd::this_thread::sleep_for(2s); // sleep for 2 seconds\n\t\t\tcallbackPtr(\"test_callback\", (\"fncToExecute_\" + std::to_string(i)).c_str(), fnc.c_str());\n\t\t}\n\n\t}, function).detach();\n}\n</syntaxhighlight>\n</spoiler>"
- "Since Arma 3 v2.11: <sqf>hint (\"myExtContext\" callExtension \"\");</sqf>\nHere is a minimal example: <spoiler>\n<syntaxhighlight lang=\"cpp\">\n#include <string>\n#include <vector>\n#include <iterator>\n#include <sstream>\n#include <iomanip>\n \nBOOL APIENTRY DllMain( HMODULE hModule,\n                       DWORD  ul_reason_for_call,\n                       LPVOID lpReserved\n                     )\n{\n    switch (ul_reason_for_call)\n    {\n    case DLL_PROCESS_ATTACH:\n    case DLL_THREAD_ATTACH:\n    case DLL_THREAD_DETACH:\n    case DLL_PROCESS_DETACH:\n        break;\n    }\n    return TRUE;\n}\n \nstd::vector<std::string> contextInfo;\n \nextern \"C\"\n{\n\t//--- User entry point\n\t__declspec (dllexport) void __stdcall RVExtension(char *output, int outputSize, const char *function);\n\t//--- Engine passed context\n\t__declspec (dllexport) void __stdcall RVExtensionContext(const char **args, int argsCnt);\n}\n \n//--- name callExtension function\nvoid __stdcall RVExtension(char *output, int outputSize, const char *function)\n{\n\t//--- Not used here\n\t(void)function;\n \n\tif (!contextInfo.empty())\n\t{\n\t\tstd::ostringstream oss;\n\t\tconst char qt = '\"';\n \n\t\tfor (auto it = contextInfo.begin(); it != contextInfo.end() - 1; ++it)\n\t\t\toss << std::quoted(*it, qt, qt) << \",\";\n\t\toss << std::quoted(contextInfo.back(), qt, qt);\n \n\t\t//--- Send context info back\n\t\tstrncpy_s(output, outputSize, (\"[\" + oss.str() + \"]\").c_str(), _TRUNCATE);\n\t}\n}\n \n//--- Context is executed first, copy it\nvoid __stdcall RVExtensionContext(const char **args, int argsCnt)\n{\n\tcontextInfo.assign(args, std::next(args, argsCnt));\n}\n</syntaxhighlight>\n</spoiler>"
