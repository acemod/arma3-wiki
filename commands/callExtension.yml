name: callExtension
description: |-
  Calls custom .dll also known as [[Extensions|Extension]]. The name of the extension is the name of the extension .dll without ".dll" part (or without "_x64.dll" part on 64-bit Arma). For example if the file is 'myExtension.dll' the name of the extension will be "myExtension". For 64-bit extensions, the name of the extension doesn't need to change and is still "myExtension". The game will automatically look for 'myExtension_x64.dll' when you use 64-bit Arma exe.
  <br><br>
  This command is blocking, meaning that the game will wait for the extension to return before continuing. This may cause FPS drop if extension is not optimised. If extension takes too long, consider making asynchronous extension, where the result of the work of the extension is collected in a separate call.
  <br><br>
  Currently there is no limit how much data you can send to the extension. However there is a limit on how much data you can return from extension in one call. The limit is known to the extension and is passed in {{hl| int outputSize}}. The limit may or may not change in the future and is currently 10240 bytes. It is up to extension designer to handle multipart results if returned data exceeds output limit.
  <br><br>
  Since {{arma3}} v1.68 it is possible to pass array of arguments to extensions. The array of arguments could be anything and all elements will be converted to strings, however you might want to only send simple types like [[Boolean]]s, [[String]]s, [[Number]]s and [[Array]]s of all of the above. There is currently a limit on how many arguments can be sent and it is 2048 (since Arma 3 v1.92; previous limit: 1024). However an argument could be an [[Array]] itself, in this case extension maker will have to provide additional methods for parsing such arguments.
  <br><br>
  Possible error codes:
  * 101: SYNTAX_ERROR_WRONG_PARAMS_SIZE
  * 102: SYNTAX_ERROR_WRONG_PARAMS_TYPE
  * 201: PARAMS_ERROR_TOO_MANY_ARGS
  * 301: EXECUTION_WARNING_TAKES_TOO_LONG
  Each error will have entry in .rpt file with more details.<br><br>

  The extension execution timeout, after which {{hl|301: EXECUTION_WARNING_TAKES_TOO_LONG}} warning is issued, is hardcoded on clients and is 1000.0 milliseconds (1 second). On the server the default limit is also 1 second, however it is possible to set custom limit with {{hl|callExtReportLimit}} param (see [[server.cfg#Server_Options | Server Options]]).
  <br><br>
  If an extension with the given name cannot be found (or it is found but doesn't implement the required interface properly / at all) the following error will be written into the RPT (In this example the given dll-name was "MyExtension"):
  <code style="display: block">14:27:07 CallExtension 'MyExtension' could not be found</code>
  <br>
  If an extension is not whitelisted with BattlEye (see [[Extensions]] for more info) it will be blocked on clients running with enabled BattlEye protection. RPT message outputted however is a little obscure:
  <code style="display: block">21:35:04 Call extension 'MyExtension' could not be loaded: Insufficient system resources exist to complete the requested service</code>
  <br>
  Since {{arma3}} v1.70, {{hl|RVExtensionVersion}} interface (see source code example below) has been added, which is called by the engine on extension load and expects extension version. This interface is designed to work with both, Linux and Windows. The max buffer size is 32 bytes. The version information will then appear in .[[rpt]] file like so:
  <code style="display: block">19:06:36 CallExtension loaded: test_extension (.\test_extension.dll) [1.0.0.1]</code>
  <br>
  For more information see [[Extensions]].
  <br><br>
  <u>Linux specific</u><br>
  While on Windows the extension name is case-insensitive, on Linux the extension name is case-sensitive and should match the name of the .so file exactly (minus ".so" part).<br><br>

  {{Feature|important|
  If a user has '''anti-virus software real time protection running''', this could cause brand new extension to stutter the game and return with {{hl|EXECUTION_WARNING_TAKES_TOO_LONG}} when executed for the first time, because of the AV software scanning.
  After the extension is whitelisted by AV this should go away until a new version of the extension is installed.
  Perhaps a dummy call to the extension on init should be considered as a feature of implementation to account for that.
  }}
  <br>

  '''<u>Extension Context</u>'''

  Since {{arma3}} v2.12 the engine will call the {{hl|RVExtensionContext}} method (if it exists, see {{Link|#Example 4}}) and pass the following data:
  * {{hl|steamID}} of the client calling extension [[getPlayerUID]] or "0"
  * {{hl|fileSource}} from which the extension was executed or "" if done on the fly
  * {{hl|missionName}} [[missionNameSource]]
  * {{hl|serverName}} [[serverName]]
groups:
- System
syntax:
- call: !Binary
  - extension
  - function
  ret:
  - String
  - data sent back from extension; If the extensiion was not found an empty String will be returned
  params:
  - name: extension
    description: extension name
    type: String
  - name: function
    description: data sent to the extension
    type: String
- call: !Binary
  - extension
  - - function
    - arguments
  ret:
  - Unknown
  - null
  params:
  - name: extension
    description: extension name
    type: String
  - name: function
    description: extension function identifier
    type: String
  - name: arguments
    description: 'function arguments. Could be array of [[Anything]], each element will be converted to [[String]] automatically. Current allowed max length of this array is 2048 (since Arma 3 v1.92; previous limit: 1024)'
    type: Unknown
  since:
    arma_3:
      major: 1
      minor: 68
argument_loc: Unspecified
effect_loc: Unspecified
since:
  arma_2_arrowhead:
    major: 1
    minor: 60
  take_on_helicopters:
    major: 1
    minor: 0
  arma_3:
    major: 0
    minor: 50
examples:
- _return = "myExtension" callExtension "stringToBeParsed";
- |
  _result = "test_extension" callExtension str weapons player;
  _result = "test_extension" callExtension ["fnc1", getUnitLoadout player];
  _result = "test_extension" callExtension ["fnc2", magazinesAmmoFull player];
  _result = "test_extension" callExtension ["fnc1", [weapons player, magazines player]];
- "_result = \"test_extension\" callExtension [\"fnc1\", [1, \"two\", true, [4, \"five\", false]]];\nparseSimpleArray (_result select 0) params [\"_number\",\"_string\",\"_boolean\",\"_array\"];\nsystemChat str [_number,_string,_boolean,_array];\n</sqf>\n<br>\n<u>Source Code</u> ({{Link|link= http://data.bistudio.com/a3data/test_extension.zip|text= Download .dll}})\n<spoiler>\nThis is an example of an extension compatible with both syntaxes. When using 1st syntax, the data is just copied from input to output. When using alt syntax, the arguments are parsed and then assembled back into string array in 2 ways: fnc1 and fnc2. fnc1 is a fraction faster.\n<syntaxhighlight lang=\"cpp\">\n#include <string>\n#include <vector>\n#include <iterator>\n#include <sstream>\n\n#define CURRENT_VERSION \"1.0.0.1\"\n\nextern \"C\"\n{\n\t//--- Engine called on extension load\n\t__declspec (dllexport) void __stdcall RVExtensionVersion(char *output, int outputSize);\n\t//--- STRING callExtension STRING\n\t__declspec (dllexport) void __stdcall RVExtension(char *output, int outputSize, const char *function);\n\t//--- STRING callExtension ARRAY\n\t__declspec (dllexport) int __stdcall RVExtensionArgs(char *output, int outputSize, const char *function, const char **args, int argsCnt);\n}\n\n//--- Extension version information shown in .rpt file\nvoid __stdcall RVExtensionVersion(char *output, int outputSize)\n{\n\t//--- max outputSize is 32 bytes\n\tstrncpy_s(output, outputSize, CURRENT_VERSION, _TRUNCATE);\n}\n\n//--- name callExtension function\nvoid __stdcall RVExtension(char *output, int outputSize, const char *function)\n{\n\tstd::string str = function;\n\tstrncpy_s(output, outputSize, (\"Input Was: \" + str).c_str(), _TRUNCATE);\n}\n\n//--- name callExtension [function, args]\nint __stdcall RVExtensionArgs(char *output, int outputSize, const char *function, const char **args, int argsCnt)\n{\n\tif (strcmp(function, \"fnc1\") == 0)\n\t{\n\t\t//--- Manually assemble output array\n\t\tint i = 0;\n\t\tstd::string str = \"[\";\n\n\t\t//--- Each argument can be accessed via args[n]\n\t\tif (argsCnt > 0)\n\t\t\tstr += args[i++];\n\n\t\twhile (i < argsCnt)\n\t\t{\n\t\t\tstr += \",\";\n\t\t\tstr += args[i++];\n\t\t}\n\n\t\tstr += \"]\";\n\n\t\t//--- Extension result\n\t\tstrncpy_s(output, outputSize, str.c_str(), _TRUNCATE);\n\n\t\t//--- Extension return code\n\t\treturn 100;\n\t}\n\n\telse if (strcmp(function, \"fnc2\") == 0)\n\t{\n\t\t//--- Parse args into vector\n\t\tstd::vector<std::string> vec(args, std::next(args, argsCnt));\n\n\t\tstd::ostringstream oss;\n\t\tif (!vec.empty())\n\t\t{\n\t\t\t//--- Assemble output array\n\t\t\tstd::copy(vec.begin(), vec.end() - 1, std::ostream_iterator<std::string>(oss, \",\"));\n\t\t\toss << vec.back();\n\t\t}\n\n\t\t//--- Extension result\n\t\tstrncpy_s(output, outputSize, (\"[\" + oss.str() + \"]\").c_str(), _TRUNCATE);\n\n\t\t//--- Extension return code\n\t\treturn 200;\n\t}\n\n\telse\n\t{\n\t\tstrncpy_s(output, outputSize, \"Avaliable Functions: fnc1, fnc2\", outputSize - 1);\n\t\treturn -1;\n\t}\n}\n</syntaxhighlight>\n</spoiler>"
- "Since {{arma3}} v2.12: <sqf>hint (\"myExtContext\" callExtension \"\");</sqf>\nHere is a minimal example: <spoiler>\n<syntaxhighlight lang=\"cpp\">\n#include <string>\n#include <vector>\n#include <iterator>\n#include <sstream>\n#include <iomanip>\n\nBOOL APIENTRY DllMain(\tHMODULE hModule,\n\t\t\t\t\t\tDWORD ul_reason_for_call,\n\t\t\t\t\t\tLPVOID lpReserved)\n{\n\tswitch (ul_reason_for_call)\n\t{\n\t\tcase DLL_PROCESS_ATTACH:\n\t\tcase DLL_THREAD_ATTACH:\n\t\tcase DLL_THREAD_DETACH:\n\t\tcase DLL_PROCESS_DETACH:\n\t\t\tbreak;\n\t}\n\treturn TRUE;\n}\n\nstd::vector<std::string> contextInfo;\n\nextern \"C\"\n{\n\t//--- User entry point\n\t__declspec (dllexport) void __stdcall RVExtension(char *output, int outputSize, const char *function);\n\t//--- Engine passed context\n\t__declspec (dllexport) void __stdcall RVExtensionContext(const char **args, int argsCnt);\n}\n\n//--- name callExtension function\nvoid __stdcall RVExtension(char *output, int outputSize, const char *function)\n{\n\t//--- Not used here\n\t(void)function;\n\n\tif (!contextInfo.empty())\n\t{\n\t\tstd::ostringstream oss;\n\t\tconst char qt = '\"';\n\n\t\tfor (auto it = contextInfo.begin(); it != contextInfo.end() - 1; ++it)\n\t\t\toss << std::quoted(*it, qt, qt) << \",\";\n\t\toss << std::quoted(contextInfo.back(), qt, qt);\n\n\t\t//--- Send context info back\n\t\tstrncpy_s(output, outputSize, (\"[\" + oss.str() + \"]\").c_str(), _TRUNCATE);\n\t}\n}\n\n//--- Context is executed first, copy it\nvoid __stdcall RVExtensionContext(const char **args, int argsCnt)\n{\n\tcontextInfo.assign(args, std::next(args, argsCnt));\n}\n</syntaxhighlight>\n</spoiler>"
