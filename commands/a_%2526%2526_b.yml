name: '&&'
desc: |-
  Returns [[true]] only if both conditions are [[true]].
  In case of the alternative syntax, {{Link|https://en.wikipedia.org/wiki/Lazy_evaluation#Control_structures|lazy evaluation}} is used - if left operand is [[false]], evaluation of the right side is ignored.
alias:
- '[[a and b]]'
groups:
- Variables
- Math
syntax:
- ret:
    type: Boolean
  left: !Item
    name: booleanA
    desc: test condition or variable
    type: Boolean
  right: !Item
    name: booleanB
    desc: test condition or variable
    type: Boolean
- ret:
    type: Boolean
  left: !Item
    name: boolean
    desc: test condition or variable
    type: Boolean
  right: !Item
    name: code
    desc: code that once executed returns a [[Boolean]]. The code is not evaluated if '''boolean''' is [[false]].
    type: Code
  since:
    arma2oa: '1.62'
argument_loc: Unspecified
effect_loc: Unspecified
since:
  flashpoint: '1.0'
  flashpoint_elite: '1.0'
  arma1: '1.0'
  arma2: '1.0'
  arma2oa: '1.50'
  tkoh: '1.0'
  arma3: '0.50'
examples:
- "<sqf>\nprivate _allEnemiesKilled = true;\nif (alive player && _allEnemiesKilled) then\n{\n\thint \"you win !\";\n};\n</sqf>"
- "<sqf>\nif ((count _array > 0) && { (_array select 0) == player }) then // an error would be thrown without lazy evaluation\n{\n\thint \"It works!\";\n};\n</sqf>"
- "<sqf>\nif ((alive player) && { player setDamage 0.5; true }) then // valid AS LONG AS the code block returns a Boolean\n{\n\thint \"It works!\";\n};\n</sqf>"
see_also:
- and
- or
- Operators
